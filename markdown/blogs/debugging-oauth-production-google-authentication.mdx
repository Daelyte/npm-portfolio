---
title: "Debugging Google OAuth in Production: A 3-Hour Deep Dive"
published_at: "2025-01-11"
description: "How I fixed a production OAuth callback issue causing 8+ code exchanges and broken sessions. Real debugging process, root cause analysis, and security implementation."
slug: "debugging-oauth-production-google-authentication"
---

# Debugging Google OAuth in Production: A 3-Hour Deep Dive

**Context**: Frame Economics (framearchitech.com) - A behavioral psychology learning platform serving 200-350 daily users.

**Problem**: Users could authenticate with Google, but sessions weren't being captured. Users remained logged out despite successful OAuth flow.

## The Symptoms

Console showed a confusing state:
```
[Auth] state change: SIGNED_OUT false
```

Google's OAuth popup appeared, user authenticated successfully, redirect happened - but the session was lost. In production. With active users trying to log in.

## Investigation Process

### Initial Hypothesis: Session Storage Issue

First check - browser DevTools Network tab. Found something immediately wrong:

```http
POST /auth/v1/token
Status: 400 Bad Request
Body: "Authorization code has already been used"
```

Not once. **Eight times**. The authorization code was being exchanged 8+ times in rapid succession.

### Root Cause #1: Multiple Code Exchanges

Diving into `src/contexts/AuthContext.tsx`:

```typescript
// The problem: No safeguard against multiple exchanges
useEffect(() => {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    async (event, session) => {
      if (event === 'SIGNED_IN' && window.location.hash.includes('code=')) {
        // This was running multiple times!
        const code = new URLSearchParams(window.location.hash.substring(1)).get('code');
        await supabase.auth.exchangeCodeForSession(code);
      }
    }
  );
}, []);
```

**Why it failed**: 
- Popup window exchanged the code
- Parent window exchanged the code  
- Auth state change triggered more exchanges
- Each failed exchange triggered another state change
- Infinite loop of failures

### Solution #1: Exchange Attempt Flag

```typescript
const exchangeAttemptedRef = useRef(false);

useEffect(() => {
  const urlParams = new URLSearchParams(window.location.search);
  const isPopup = urlParams.get('popup') === '1';
  const isCallback = window.location.pathname === '/auth/callback';
  
  // Skip exchange in popup windows or callback routes
  if (isPopup || isCallback) {
    exchangeAttemptedRef.current = true;
    return;
  }

  if (exchangeAttemptedRef.current) return;
  
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    async (event, session) => {
      if (event === 'SIGNED_IN') {
        exchangeAttemptedRef.current = true;
        // Only exchange once in main window
      }
    }
  );
}, []);
```

### Root Cause #2: Browser Cache Disabled

DevTools had "Disable cache" checked. OAuth relies on cookies for session management. With cache disabled:

- Session cookies weren't being stored
- Each page load started fresh
- No persistent authentication state

**Critical lesson**: Always check DevTools settings when debugging auth issues.

### Root Cause #3: Popup Window Handling

The OAuth flow used a popup window, but both windows tried to handle the callback:

```typescript
// In App.tsx - Popup detection
useEffect(() => {
  const urlParams = new URLSearchParams(window.location.search);
  const isPopup = urlParams.get('popup') === '1';
  
  if (isPopup && window.opener) {
    // Popup only sends message, doesn't exchange code
    window.opener.postMessage({ type: 'oauth_complete' }, window.location.origin);
    window.close();
    return;
  }
  
  // Main window waits for session before proceeding
  const handleOAuthComplete = async (event) => {
    if (event.data?.type === 'oauth_complete') {
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        window.location.hash = '';
      }
    }
  };
  
  window.addEventListener('message', handleOAuthComplete);
}, []);
```

## The Fix: Three-Part Solution

### 1. Simplified OAuth Redirect Configuration

```typescript
// src/lib/supabase.ts
export const signInWithProvider = async (provider: 'google' | 'github') => {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider,
    options: {
      redirectTo: `${SITE_URL}/auth/callback`, // Single, simple callback
    },
  });
  return { data, error };
};
```

### 2. PKCE Flow Configuration

```typescript
export const supabase = createClient<Database>(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      storage: window.localStorage,
      storageKey: 'framearchitech-auth',
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      flowType: 'pkce', // Proof Key for Code Exchange - more secure
    },
  }
);
```

**Why PKCE?**
- Prevents authorization code interception
- No client secret needed on frontend
- Industry standard for SPAs
- Built-in protection against replay attacks

### 3. Row Level Security Verification

While fixing OAuth, discovered RLS policies had wrong column references:

```sql
-- Before (broken)
CREATE POLICY "Users can update own comments" ON comments
  FOR UPDATE USING (auth.uid() = user_id);  -- Wrong column!

-- After (fixed)
CREATE POLICY "Users can update own comments" ON comments
  FOR UPDATE USING (auth.uid() = author_id);  -- Correct column
```

## Security Implementation Checklist

What I implemented for production OAuth:

✅ **PKCE Flow** - Code exchange protection  
✅ **HttpOnly Cookies** - XSS protection for session tokens  
✅ **Row Level Security** - Database-level authorization  
✅ **OAuth State Validation** - CSRF protection  
✅ **Session Refresh** - Auto-refresh tokens before expiry  
✅ **Secure Redirect** - Whitelist allowed callback URLs  

## Production Deployment

Testing in production (after staging validation):

```bash
# Build with production env vars
npm run build

# Deploy to Vercel
vercel --prod

# Monitor Supabase logs
# Watch for auth errors in real-time
```

**Result**: OAuth success rate went from ~40% to 98%+ within hours.

## Lessons Learned

### 1. Always Check DevTools Settings
Browser cache settings can break OAuth flows. Document this for team members.

### 2. Guard Against Multiple Code Exchanges
Use refs or flags to prevent race conditions in auth flows.

### 3. Separate Concerns in Popup Flow
Popup windows should only communicate via `postMessage`, not handle auth logic.

### 4. Database Column Names Matter
RLS policies fail silently if they reference wrong columns. Always test policies directly.

### 5. Monitor Production Logs
Set up Supabase log monitoring to catch auth issues immediately.

## Debugging Tools Used

- **Chrome DevTools Network Tab** - HTTP request inspection
- **Supabase Dashboard Logs** - Real-time database queries
- **Console Logging** - Strategic auth state logging
- **React DevTools** - Component re-render tracking
- **Window Debugging** - `window.supabase` exposed in dev mode

## The AI-Assisted Reality

Full transparency: I used AI assistance (Claude/GPT) throughout this debugging session for:

- Suggesting the exchange attempt flag pattern
- Reviewing OAuth security best practices
- Generating RLS policy corrections
- Explaining PKCE flow benefits

**What AI couldn't do**:
- Identify the browser cache issue (required manual inspection)
- Understand the specific codebase architecture
- Make architectural decisions about popup handling
- Debug the actual production issue in real-time

The best debugging is hybrid - AI for patterns and suggestions, human for investigation and decision-making.

## Resources

- [Supabase Auth Documentation](https://supabase.com/docs/guides/auth)
- [OAuth 2.0 PKCE RFC](https://tools.ietf.org/html/rfc7636)
- [OWASP OAuth Security](https://owasp.org/www-community/vulnerabilities/OAuth)

---

**Tech Stack**: React 18, TypeScript, Supabase, Vite, Vercel  
**Time to Debug**: ~3 hours  
**Impact**: Unblocked 100+ users, enabled production Google OAuth
